group llvm;

mainSchema(intVars, decls, stats) ::= 
<<
; ModuleID = 'tamarahasmoldypants.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.str = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1

; Function Attrs: nounwind ssp uwtable
define i32 @.addIntegers(i32 %op1, i32 %op2) {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 %op1, i32* %1, align 4
  store i32 %op2, i32* %2, align 4
  %3 = load i32* %1, align 4
  %4 = load i32* %2, align 4
  %5 = add nsw i32 %3, %4
  ret i32 %5
}

; Function Attrs: nounwind ssp uwtable
define i32 @.subIntegers(i32 %op1, i32 %op2) {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 %op1, i32* %1, align 4
  store i32 %op2, i32* %2, align 4
  %3 = load i32* %1, align 4
  %4 = load i32* %2, align 4
  %5 = sub nsw i32 %3, %4
  ret i32 %5
}

; Function Attrs: nounwind ssp uwtable
define i32 @.multIntegers(i32 %op1, i32 %op2) {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 %op1, i32* %1, align 4
  store i32 %op2, i32* %2, align 4
  %3 = load i32* %1, align 4
  %4 = load i32* %2, align 4
  %5 = mul nsw i32 %3, %4
  ret i32 %5
}

; Function Attrs: nounwind ssp uwtable
define i32 @.divIntegers(i32 %op1, i32 %op2) {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 %op1, i32* %1, align 4
  store i32 %op2, i32* %2, align 4
  %3 = load i32* %1, align 4
  %4 = load i32* %2, align 4
  %5 = sdiv i32 %3, %4
  ret i32 %5
}

; Function Attrs: nounwind ssp uwtable
define void @printInteger(i32 %i) {
  %1 = alloca i32, align 4
  store i32 %i, i32* %1, align 4
  %2 = load i32* %1, align 4
  %3 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i32 0, i32 0), i32 %2)
  ret void
}

declare i32 @printf(i8*, ...)

define i32 @main() nounwind uwtable {
  	<intVars: {var | %<var> = alloca i32, align 4}>
<decls: {decl | <decl>}>
<stats: {statement | <statement>
}>

    ret i32 0
}

>>

intAssign(expr, var, oldcounter) ::= 
<<
	<expr>
	; assign int variable
	store i32 %<oldcounter>, i32* %<var>, align 4
>>

if(expr, label, block) ::= 
<<

>>

loop(expr, label, block) ::= 
<<

>>

print(expr, oldcounter) ::= 
<<
  <expr>
  ; print
  tail call void @printInteger(i32 %<oldcounter>)
>>

inequality(op1,op2,label) ::=
<<

>>

equality(op1,op2,label) ::=
<<


>>

greaterThan(op1,op2,label) ::=
<<

>>

lessThan(op1,op2,label) ::=
<<


>>

div(lhs, rhs, lhsLabel, rhsLabel, counter) ::=
<<

;load vars for div
<lhs>
<rhs>
;div
%<counter> = call i32 @.divIntegers(i32 %<lhsLabel>, i32 %<rhsLabel>)

>>

mult(lhs, rhs, lhsLabel, rhsLabel, counter) ::=
<<

;load vars for mult
<lhs>
<rhs>
;mult
%<counter> = call i32 @.multIntegers(i32 %<lhsLabel>, i32 %<rhsLabel>)
; store result in some known var

>>

sub(lhs, rhs, lhsLabel, rhsLabel, counter) ::=
<<
;load vars for subtraction
<lhs>
<rhs>
;subtraction
%<counter> = call i32 @.subIntegers(i32 %<lhsLabel>, i32 %<rhsLabel>) 
; store result in some known var

>>

add(lhs, rhs, lhsLabel, rhsLabel, counter) ::=
<<
<lhs>
<rhs>
; addition !
%<counter> = call i32 @.addIntegers(i32 %<lhsLabel>, i32 %<rhsLabel>)

>>

loadVariable(var, counter) ::=
<<
; load variable
%<counter> = load i32* %<var>, align 4
>>

loadConstant(value, counter, newcounter) ::=
<<
; store constant and load it into counter
%<counter> = alloca i32, align 4
store i32 <value>, i32* %<counter>, align 4
%<newcounter> = load i32* %<counter>, align 4
>>
